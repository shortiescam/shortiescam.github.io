<!DOCTYPE html>
<!-- 
    Adds `dark` class to <html> based on localStorage or OS preference.
    This must run before the body renders to prevent FOUC (Flash Of Unstyled Content).
-->
<script>
    if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
    } else {
        document.documentElement.classList.remove('dark');
    }
</script>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- 
        Viewport meta tags to prevent zooming and ensure proper scaling on mobile.
        user-scalable=no, maximum-scale=1.0 are crucial for a native-app feel.
        viewport-fit=cover is added for better edge-to-edge display on modern phones.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Shorties - 6 Second Video</title>
    
    <link rel="icon" type="image/png" href="https://i.ibb.co/93dkgst4/video-video-call-camera-record-svgrepo-com.png">

    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Load Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <style>
        /* Base styles */
        html, body {
            height: 100%;
            overflow: hidden; /* Prevent scrolling on the body */
        }
        
        body {
            font-family: 'Inter', sans-serif;
            /* Prevent overscroll bounce on iOS */
            overscroll-behavior-y: none;
            /* Prevent text selection when holding buttons */
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            /* Default light mode colors.
                These are overridden by dark mode styles below.
            */
            background-color: #ffffff; /* bg-white */
            color: #111827; /* text-gray-900 */
            transition: background-color 0.2s linear, color 0.2s linear;
        }
        
        /* --- Dark Mode Styles --- */
        html.dark body {
            background-color: #111827; /* bg-gray-900 */
            color: #f3f4f6; /* text-gray-100 */
        }
        html.dark #loading-view {
            background-color: #111827; /* bg-gray-900 */
        }
        html.dark #loading-view p,
        html.dark #permissions-view p,
        html.dark #recording-view p.text-gray-600,
        html.dark #library-view p {
            color: #9ca3af; /* text-gray-400 */
        }
        html.dark .bg-gray-200 {
            background-color: #374151; /* bg-gray-700 */
            color: #f9fafb; /* text-gray-50 */
        }
        html.dark .bg-gray-200:hover {
            background-color: #4b5563; /* bg-gray-600 */
        }
        html.dark .bg-gray-800 {
            background-color: #030712; /* bg-gray-950 */
        }
        /* Modal dark styles */
        html.dark #download-modal .bg-white,
        html.dark #library-modal-content {
            background-color: #1f2937; /* bg-gray-800 */
        }
        html.dark #download-modal .text-gray-900,
        html.dark #library-modal-content .text-gray-900 {
            color: #f9fafb; /* text-gray-50 */
        }
        html.dark #download-modal .text-gray-600,
        html.dark #library-modal-content .text-gray-600 {
            color: #9ca3af; /* text-gray-400 */
        }
        html.dark #download-modal .bg-gray-200 {
            background-color: #4b5563; /* bg-gray-600 */
        }
        html.dark #download-modal .bg-gray-200:hover {
            background-color: #525c6a;
        }
        html.dark .library-item {
            background-color: #374151; /* bg-gray-700 */
        }
        html.dark .modal-actions-container {
             background-color: #111827; /* bg-gray-900 */
        }

        /* Force 1:1 aspect ratio for video containers */
        .aspect-square {
            position: relative;
            width: 100%;
            padding-bottom: 100%; /* 1:1 Aspect Ratio */
            height: 0;
            overflow: hidden;
            border-radius: 1.5rem; /* rounded-3xl */
        }

        .aspect-square > video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Fill the square, cropping as needed */
            cursor: pointer; /* Add pointer cursor to indicate it's clickable */
            /* FIX: Prevents the grey background flash on mobile before video loads.
              This sets a black background, which is less jarring than the
              browser default (a grey box with a play icon).
            */
            background-color: #000;
        }
        
        /* Circular progress bar */
        .progress-ring__circle {
            transition: stroke-dashoffset 0.1s linear;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            stroke: #3b82f6; /* blue-500 */
        }
        html.dark .progress-ring__circle_bg {
            color: #374151; /* bg-gray-700 */
        }
        
        /* --- Record Button Animations --- */
        @keyframes pulse-record {
            0%, 100% {
                transform: scale(1);
                /* Using a blue shadow for the new lock button, 
                   but it will be overridden by .is-recording-hold */
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); /* blue-500 */
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }
        }
        /* Specific pulse for hold button */
        .is-recording-hold {
            animation: pulse-record 1.5s infinite;
        }
        @keyframes pulse-record-hold {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); /* red-500 */
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
        }
        .is-recording-hold {
            animation: pulse-record-hold 1.5s infinite;
        }

        /* Specific pulse for lock button */
        @keyframes pulse-record-lock {
             0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); /* blue-500 */
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }
        }
        .is-recording-lock {
             animation: pulse-record-lock 1.5s infinite;
        }


        @keyframes riffle-paused {
            0% {
                box-shadow: 0 0 0 0px rgba(107, 114, 128, 0.4); /* gray-500 */
            }
            70% {
                box-shadow: 0 0 0 15px rgba(107, 114, 128, 0);
            }
            100% {
                box-shadow: 0 0 0 0px rgba(107, 114, 128, 0);
            }
        }
        .is-paused {
            animation: riffle-paused 2s infinite ease-out;
        }
        
        /* Toast notification */
        #toast {
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            transform: translateY(100%);
            opacity: 0;
            z-index: 100;
            /* Adjust for safe area */
            margin-bottom: env(safe-area-inset-bottom, 1rem);
        }
        
        #toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        /* Hide scrollbars for the main container */
        #app-container::-webkit-scrollbar {
            display: none;
        }

        /* MOBILE SAFE AREA: Add padding for scrolling content */
        #app-container {
            padding-bottom: calc(1rem + env(safe-area-inset-bottom));
        }
        
        /* MOBILE SAFE AREA: Add padding to the bottom of fixed-view controls to avoid system nav bars */
        #recording-controls, #preview-actions {
            padding-bottom: env(safe-area-inset-bottom, 1rem);
        }

        /* Loading Spinner */
        #loading-view {
            z-index: 200;
        }
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3b82f6; /* Blue */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        html.dark .loader {
             border: 4px solid #374151; /* Dark grey */
             border-top: 4px solid #3b82f6; /* Blue */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* --- Improved Custom Video Controls --- */
        .video-player-container {
            position: relative;
            background: #000; /* Black background for 1:1 player */
            border-radius: 1.5rem; /* rounded-3xl */
        }
        
        .custom-controls-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.7), rgba(0,0,0,0));
            padding: 12px;
            padding-top: 24px; /* More space on top */
            border-bottom-left-radius: 1.5rem; /* match video */
            border-bottom-right-radius: 1.5rem; /* match video */
            z-index: 22;
        }
        
        .play-pause-btn {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 50%;
            width: 44px; /* Slightly larger */
            height: 44px; /* Slightly larger */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .play-pause-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Custom progress bar */
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden; /* Ensure progress bar stays within bounds */
            margin-bottom: 8px; /* Space between bar and buttons */
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background: #3b82f6; /* blue-500 */
            border-radius: 4px;
            transition: width 0.1s linear; /* Smooth progress */
        }
        
        /* Big center play button */
        .big-play-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 21;
            transition: opacity 0.3s ease, transform 0.2s ease, visibility 0.3s ease;
            opacity: 0;
            visibility: hidden;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        .big-play-button:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }
        
        /* Show when paused */
        .video-player-container.paused .big-play-button {
            opacity: 1;
            visibility: visible;
        }

        .big-play-button i.fa-play {
            font-size: 40px;
            color: white;
            /* Nudge icon for better visual centering */
            margin-left: 4px; 
        }
        
        /* Center play icon in smaller button */
        .play-pause-btn i.fa-play {
             /* Nudge icon for better visual centering */
            margin-left: 2px;
        }

        /* --- Modal Styles --- */
        #download-modal, #library-modal {
            z-index: 150;
        }
        
        /* Library Modal (1:1 Aspect Ratio) */
        #library-modal-content {
            width: 100%;
            max-width: 500px; /* Max width */
            padding-bottom: 100%; /* 1:1 padding hack */
            position: relative;
        }
        
        #library-modal-body {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
        }
        
        #library-modal-player-container {
            width: 100%;
            height: 100%; /* Fill the 1:1 space */
        }

        #library-modal-player-container video {
             border-radius: 0; /* No radius inside modal */
             /* FIX: Prevents the grey background flash on mobile before video loads.
             */
             background-color: #000;
        }
        
        /* Library Grid */
        #library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.50rem;
        }
        
        .library-item {
            position: relative;
            aspect-ratio: 1 / 1;
            background: #e5e7eb; /* bg-gray-200 */
            border-radius: 0.75rem; /* rounded-lg */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 0.5rem;
            cursor: pointer;
            overflow: hidden;
            text-align: center;
        }
        
        .library-item-thumbnail {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .library-item-icon {
            font-size: 2.5rem; /* text-4xl */
            color: #6b7280; /* text-gray-500 */
        }
        html.dark .library-item-icon {
             color: #d1d5db; /* text-gray-300 */
        }

        .library-item-date {
            font-size: 0.75rem; /* text-xs */
            color: #fff;
            position: absolute;
            bottom: 8px;
            background: rgba(0,0,0,0.5);
            padding: 2px 6px;
            border-radius: 4px;
        }
        html.dark .library-item-date {
            color: #f9fafb;
        }
        
        .library-item-delete {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            background: rgba(0,0,0,0.4);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            z-index: 10;
        }
        .library-item-delete:hover {
            background: rgba(239, 68, 68, 0.8); /* red-500 */
        }
    </style>
</head>

<body class="overflow-hidden h-screen">

    <!-- Loading Screen (Visible on start) -->
    <div id="loading-view" class="fixed inset-0 bg-white flex flex-col items-center justify-center">
        <div class="loader"></div>
        <p class="mt-4 text-gray-600">Initializing App...</p>
    </div>

    <!-- Main App Container -->
    <!-- h-full was changed to h-screen to work on 100vh devices -->
    <div class="flex flex-col h-screen max-w-md mx-auto">
        
        <!-- Header -->
        <header class="flex items-center justify-between p-4 w-full relative">
            <!-- Library Button -->
            <button id="library-button" class="w-10 h-10 rounded-full flex items-center justify-center text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors">
                <i class="fas fa-folder-open text-xl"></i>
            </button>
            
            <!-- Centered Title -->
            <h1 class="text-2xl font-bold text-blue-500 absolute left-1/2 -translate-x-1/2">Shorties</h1>
            
            <!-- Dark Mode Toggle Button -->
            <button id="theme-toggle-button" class="w-10 h-10 rounded-full flex items-center justify-center text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors">
                <!-- Icon will be set by JS (fa-sun or fa-moon) -->
                <i id="theme-icon" class="fa-solid fa-certificate text-xl"></i>
            </button>
        </header>

        <!-- App Content Area -->
        <!-- flex-1 and overflow-y-auto allow content to scroll if needed, while header is fixed -->
        <main id="app-container" class="flex-1 flex flex-col p-4 overflow-y-auto">
            
            <!-- View 1: Permissions Screen -->
            <div id="permissions-view" class="hidden flex-1 flex flex-col items-center justify-center text-center">
                <div class="p-5 bg-blue-100 rounded-full mb-6 flex items-center justify-center" style="width: 80px; height: 80px;">
                    <!-- Font Awesome icon replacement -->
                    <i class="fas fa-video fa-2x text-blue-500"></i>
                </div>
                <h2 class="text-2xl font-bold mb-2">Ready to create a Shortie?</h2>
                <p class="text-gray-600 mb-8">We'll need access to your camera and microphone to record.</p>
                <button id="get-camera-button" class="w-full bg-blue-500 text-white font-bold py-3 px-6 rounded-xl text-lg shadow-lg hover:bg-blue-600 transition-all flex items-center justify-center">
                    <!-- Font Awesome icon added -->
                    <i class="fas fa-camera mr-2"></i>
                    Enable Camera & Mic
                </button>
            </div>
            
            <!-- View 2: Recording Screen -->
            <div id="recording-view" class="hidden flex-1 flex flex-col justify-between">
                <!-- Video Preview -->
                <div class="aspect-square bg-gray-800 rounded-3xl shadow-lg w-full mx-auto">
                    <!-- 
                        'transform: scaleX(-1)' flips the preview for a "mirror" effect,
                        which is standard for front-facing cameras. The recording
                        itself is not flipped.
                        
                        NEW: Touch-action: none prevents page scroll/refresh on swipe
                    -->
                    <video id="preview" muted autoplay playsinline class="rounded-3xl" style="touch-action: none;"></video>
                </div>
                
                <!-- Recording Controls -->
                <div id="recording-controls" class="flex flex-col items-center gap-4 mt-6">
                    <!-- Progress Timer -->
                    <div class="relative w-24 h-24">
                        <svg class="w-full h-full" viewBox="0 0 100 100">
                            <!-- Background circle -->
                            <circle class="text-gray-200 progress-ring__circle_bg" stroke-width="8" stroke="currentColor" fill="transparent" r="46" cx="50" cy="50" />
                            <!-- Progress circle -->
                            <circle class="progress-ring__circle"
                                stroke-width="8"
                                stroke-dasharray="289.0265"
                                stroke-dashoffset="289.0265"
                                fill="transparent"
                                r="46" cx="50" cy="50" />
                        </svg>
                        <div id="timer-text" class="absolute top-0 left-0 w-full h-full flex items-center justify-center text-2xl font-semibold">
                            0.0s
                        </div>
                    </div>
                    
                    <!-- MODIFIED: Text changes based on state -->
                    <p id="record-instructions" class="text-gray-600 h-6">Hold to record, or swipe for Lock Mode</p>

                    <!-- REMOVED: Swipe up to lock indicator -->

                    <!-- Main Record Button Container -->
                    <div class="flex items-center justify-center w-full mt-2">
                        <!-- 
                            NEW: Wrapper to hold both buttons.
                            Only one button will be visible at a time.
                        -->
                        <div id="record-button-wrapper" class="relative w-20 h-20">
                            <!-- Hold to Record Button (Default) -->
                            <button id="record-button-hold" class="w-20 h-20 bg-red-500 rounded-full shadow-xl focus:outline-none transition-all duration-200 active:scale-95 flex items-center justify-center absolute inset-0 disabled:opacity-50">
                                <i id="record-button-hold-icon" class="fas fa-video text-white text-3xl transition-transform"></i>
                            </button>
                            <!-- Tap to Record (Locked) Button (Hidden) -->
                            <button id="record-button-lock" class="w-20 h-20 bg-blue-500 rounded-full shadow-xl focus:outline-none transition-all duration-200 active:scale-95 flex items-center justify-center absolute inset-0 hidden disabled:opacity-50">
                                <i id="record-button-lock-icon" class="fas fa-lock text-white text-3xl transition-transform"></i>
                            </button>
                        </div>
                    </div>


                    <!-- Secondary Controls (Redesigned Layout) -->
                    <div class="flex items-center justify-between gap-4 w-full mt-4">
                        <!-- NEW: Reset Button -->
                        <button id="reset-button" class="w-16 h-16 bg-gray-200 rounded-full shadow-lg hover:bg-gray-300 transition-all flex items-center justify-center text-xl text-red-500">
                            <i class="fas fa-trash-alt"></i>
                        </button>

                        <!-- Camera Flip Button -->
                        <button id="flip-camera-button" class="w-16 h-16 bg-gray-200 rounded-full shadow-lg hover:bg-gray-300 transition-all flex items-center justify-center text-xl disabled:opacity-50">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        
                        <!-- Next Button -->
                        <button id="next-button" class="flex-1 bg-gray-200 font-medium py-3 px-6 rounded-xl shadow-lg hover:bg-gray-300 transition-all flex items-center justify-center text-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Next
                            <i class="fas fa-arrow-right ml-2"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- View 3: Preview Screen -->
            <div id="preview-view" class="hidden flex-1 flex flex-col justify-between">
                <!-- Recorded Video Player with Custom Controls -->
                <div id="video-container" class="video-player-container aspect-square bg-gray-900 rounded-3xl shadow-lg w-full mx-auto paused">
                    <video id="recorded-video" loop playsinline class="rounded-3xl"></video>
                    
                    <!-- Big Center Play Button -->
                    <div id="preview-big-play-button" class="big-play-button">
                        <i class="fas fa-play"></i>
                    </div>
                    
                    <!-- Custom Player UI -->
                    <div id="preview-custom-controls" class="custom-controls-container flex flex-col">
                        <!-- Custom Progress Bar -->
                        <div id="preview-progress-bar-container" class="progress-bar-container">
                            <div id="preview-progress-bar" class="progress-bar"></div>
                        </div>
                        <!-- Controls Row -->
                        <div class="flex items-center justify-between">
                            <button id="preview-play-pause-btn" class="play-pause-btn">
                                <i id="preview-play-pause-icon" class="fas fa-play"></i>
                            </button>
                            <button id="preview-mute-btn" class="play-pause-btn">
                                <i id="preview-mute-icon" class="fas fa-volume-high"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div id="preview-actions" class="flex flex-col gap-3 mt-6">
                    <h3 class="text-xl font-semibold text-center mb-2">Your Shortie is ready!</h3>
                    
                    <!-- Download Button -->
                    <button id="download-video-button" class="w-full text-center bg-blue-500 text-white font-bold py-3 px-6 rounded-xl text-lg shadow-lg hover:bg-blue-600 transition-all flex items-center justify-center">
                        <i class="fas fa-download mr-2"></i>
                        Save to Device
                    </button>
                    
                    <!-- Record Another Button -->
                    <button id="record-another-button" class="w-full bg-gray-200 font-medium py-3 px-6 rounded-xl shadow-lg hover:bg-gray-300 transition-all flex items-center justify-center">
                        <i class="fas fa-redo mr-2"></i>
                        Record Another
                    </button>
                </div>
            </div>
            
            <!-- View 4: Library Screen -->
            <div id="library-view" class="hidden flex-1 flex flex-col">
                <div class="flex items-center justify-between mb-4">
                     <h2 class="text-2xl font-bold">My Library</h2>
                     <!-- Back button to go to recording view -->
                     <button id="library-back-button" class="w-10 h-10 rounded-full flex items-center justify-center text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
                
                <p class="text-gray-600 mb-6">Videos you save are stored here, on this device.</p>
                
                <!-- Grid for saved videos -->
                <div id="library-grid" class="flex-0 overflow-y-auto">
                    <!-- Library items will be injected here by JS -->
                </div>
                
                <div id="library-empty-state" class="hidden flex-1 flex-col items-center justify-center text-center p-8">
                    <i class="fas fa-folder-open text-6xl text-gray-400 mb-4"></i>
                    <h3 class="text-xl font-semibold">Library is Empty</h3>
                    <p class="text-gray-600 mt-2">Record a video and tap "Save to Device" to add it to your library.</p>
                </div>
            </div>
            
        </main>
    </div>

    <!-- Toast Notification (for errors) -->
    <div id="toast" class="fixed bottom-4 left-4 right-4 max-w-md mx-auto bg-red-500 text-white p-4 rounded-lg shadow-lg">
        <p id="toast-message">Error message goes here</p>
    </div>
    
    <!-- Download/Share Modal (Hidden by default) -->
    <div id="download-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden">
        <div class="bg-white rounded-2xl p-6 shadow-xl w-full max-w-sm text-center">
            <div class="w-16 h-16 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
                <i class="fas fa-check fa-2x text-green-500"></i>
            </div>
            <h2 class="text-xl font-bold text-gray-900 mb-2">Saved!</h2>
            <p class="text-gray-600 mb-6">Your video is saved to your device and added to your library.</p>
            <div class="flex flex-col gap-3">
                <!-- REMOVED Share Button -->
                <button id="modal-close-button" class="w-full bg-gray-200 font-medium py-3 px-5 rounded-xl shadow-lg hover:bg-gray-300 transition-all flex items-center justify-center">
                    Close
                </button>
            </div>
        </div>
    </div>
    
    <!-- Library Video Player Modal -->
    <div id="library-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 hidden" style="backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);">
        <!-- Main modal container with rounded corners and overflow hidden -->
        <div class="flex flex-col w-full max-w-md bg-transparent rounded-3xl overflow-hidden">
            
            <!-- 1:1 Aspect Ratio Content (Video Player) -->
            <div id="library-modal-content" class="bg-black shadow-xl w-full rounded-t-3xl">
                <div id="library-modal-body">
                    
                    <!-- Close Button -->
                    <button id="library-modal-close" class="absolute top-3 right-3 w-10 h-10 bg-black bg-opacity-50 rounded-full text-white flex items-center justify-center z-50">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                    
                    <!-- Video Player Container -->
                    <div id="library-modal-player-container" class="video-player-container w-full h-full rounded-none paused">
                        <video id="library-video-player" loop playsinline></video>
                        
                        <!-- Big Center Play Button -->
                        <div id="library-big-play-button" class="big-play-button">
                            <i class="fas fa-play"></i>
                        </div>
                        
                        <!-- Custom Player UI -->
                        <div id="library-custom-controls" class="custom-controls-container flex flex-col rounded-none">
                            <!-- Custom Progress Bar -->
                            <div id="library-progress-bar-container" class="progress-bar-container">
                                <div id="library-progress-bar" class="progress-bar"></div>
                            </div>
                            <!-- Controls Row -->
                            <div class="flex items-center justify-between">
                                <button id="library-play-pause-btn" class="play-pause-btn">
                                    <i id="library-play-pause-icon" class="fas fa-play"></i>
                                </button>
                                <button id="library-mute-btn" class="play-pause-btn">
                                    <i id="library-mute-icon" class="fas fa-volume-high"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Action buttons container for Library Modal -->
            <div class="modal-actions-container bg-black p-4 rounded-b-3xl">
                <div class="flex items-center justify-center gap-4">
                    <!-- REMOVED Share button -->
                    <!--
                        SECURITY NOTE: This button downloads the video to the browser's default 'Downloads' folder.
                        For security reasons, web apps CANNOT open local file paths (like C:\...) or save files to custom folders.
                        This is a universal browser rule to protect you from malicious websites.
                    -->
                    <button id="library-modal-download" class="w-full bg-blue-500 text-white font-bold py-3 px-5 rounded-xl text-lg shadow-lg hover:bg-blue-600 transition-all flex items-center justify-center">
                        <i class="fas fa-download mr-2"></i> Download
                    </button>
                </div>
            </div>

        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- UI Elements ---
            const loadingView = document.getElementById('loading-view');
            const views = {
                permissions: document.getElementById('permissions-view'),
                recording: document.getElementById('recording-view'),
                preview: document.getElementById('preview-view'),
                library: document.getElementById('library-view'),
            };
            
            // Header
            const libraryButton = document.getElementById('library-button');
            const themeToggleButton = document.getElementById('theme-toggle-button');
            const themeIcon = document.getElementById('theme-icon');
            
            // Permissions
            const getCameraButton = document.getElementById('get-camera-button');
            
            // Recording
            const previewVideo = document.getElementById('preview');
            // NEW: Record button elements
            const recordButtonHold = document.getElementById('record-button-hold');
            const recordButtonHoldIcon = document.getElementById('record-button-hold-icon');
            const recordButtonLock = document.getElementById('record-button-lock');
            const recordButtonLockIcon = document.getElementById('record-button-lock-icon');
            
            const recordInstructions = document.getElementById('record-instructions');
            // REMOVED: swipeLockIndicator
            const nextButton = document.getElementById('next-button');
            const flipCameraButton = document.getElementById('flip-camera-button');
            const resetButton = document.getElementById('reset-button');
            const timerText = document.getElementById('timer-text');
            const progressCircle = document.querySelector('.progress-ring__circle');
            
            // Preview Screen Elements
            const videoContainer = document.getElementById('video-container');
            const recordedVideo = document.getElementById('recorded-video');
            const previewBigPlayButton = document.getElementById('preview-big-play-button');
            const previewPlayPauseBtn = document.getElementById('preview-play-pause-btn');
            const previewPlayPauseIcon = document.getElementById('preview-play-pause-icon');
            const previewProgressBarContainer = document.getElementById('preview-progress-bar-container');
            const previewProgressBar = document.getElementById('preview-progress-bar');
            const previewMuteBtn = document.getElementById('preview-mute-btn'); 
            const previewMuteIcon = document.getElementById('preview-mute-icon');
            const downloadVideoButton = document.getElementById('download-video-button');
            const recordAnotherButton = document.getElementById('record-another-button');
            
            // Library Screen
            const libraryGrid = document.getElementById('library-grid');
            const libraryEmptyState = document.getElementById('library-empty-state');
            const libraryBackButton = document.getElementById('library-back-button');
            
            // Library Modal
            const libraryModal = document.getElementById('library-modal');
            const libraryModalClose = document.getElementById('library-modal-close');
            const libraryPlayerContainer = document.getElementById('library-modal-player-container');
            const libraryVideoPlayer = document.getElementById('library-video-player');
            const libraryBigPlayButton = document.getElementById('library-big-play-button');
            const libraryPlayPauseBtn = document.getElementById('library-play-pause-btn');
            const libraryPlayPauseIcon = document.getElementById('library-play-pause-icon');
            const libraryProgressBarContainer = document.getElementById('library-progress-bar-container');
            const libraryProgressBar = document.getElementById('library-progress-bar');
            const libraryMuteBtn = document.getElementById('library-mute-btn');
            const libraryMuteIcon = document.getElementById('library-mute-icon');
            const libraryModalDownload = document.getElementById('library-modal-download');
            
            // Download Modal
            const downloadModal = document.getElementById('download-modal');
            const modalCloseButton = document.getElementById('modal-close-button');
            
            // Toast
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toast-message');

            // --- State Variables ---
            let mediaRecorder;
            let stream;
            let recordedChunks = [];
            let recordedBlob;
            let totalRecordedTime = 0; // in milliseconds
            let chunkStartTime = 0;
            let recordingInterval;
            // REMOVED: countdownInterval
            const MAX_DURATION = 6000; // 6 seconds
            let facingMode = 'user'; // 'user' (front) or 'environment' (back)
            let currentView = '';
            let db; // IndexedDB instance
            let libraryModalBlob = null; // Holds the blob for the video in the library modal
            
            // NEW: Record Mode state
            let currentRecordMode = 'hold'; // 'hold' or 'lock'
            
            // NEW: Swipe tracking variables
            let swipeStartX = 0;
            let swipeStartY = 0;
            const SWIPE_THRESHOLD = 50; // Min pixels for a horizontal swipe

            // --- Constants ---
            const circumference = 2 * Math.PI * 46; // 2 * pi * r
            const DB_NAME = 'ShortiesDB';
            const DB_VERSION = 1;
            const STORE_NAME = 'videos';

            // --- Initialization ---
            async function init() {
                progressCircle.style.strokeDashoffset = circumference;
                updateThemeIcon();
                
                setupEventListeners();

                try {
                    await initDB();
                    await checkPermissionsAndStart();
                } catch (err) {
                    console.error("Initialization failed:", err);
                    showToast("Could not load library storage.");
                    showView('permissions'); // Show app anyway, but library might fail
                } finally {
                    loadingView.classList.add('hidden');
                }
            }

            function setupEventListeners() {
                libraryButton.addEventListener('click', () => showView('library'));
                themeToggleButton.addEventListener('click', toggleTheme);
                getCameraButton.addEventListener('click', requestCameraAndStart);
                flipCameraButton.addEventListener('click', flipCamera);
                resetButton.addEventListener('click', resetRecordingProgress);
                
                // NEW: Event listeners for new record buttons
                recordButtonHold.addEventListener('pointerdown', handleHoldPointerDown);
                // We no longer need a window-wide 'pointerup' for hold, 
                // it's added dynamically in handleHoldPointerDown
                recordButtonLock.addEventListener('click', handleLockClick);
                
                // NEW: Swipe listeners on video preview
                previewVideo.addEventListener('pointerdown', handleSwipeStart);
                previewVideo.addEventListener('pointerup', handleSwipeEnd);

                nextButton.addEventListener('click', finishRecording);
                downloadVideoButton.addEventListener('click', downloadAndSaveToLibrary);
                recordAnotherButton.addEventListener('click', () => {
                    resetRecordingProgress();
                    requestCameraAndStart();
                });
                libraryBackButton.addEventListener('click', () => {
                    checkPermissionsAndStart();
                });
                modalCloseButton.addEventListener('click', () => downloadModal.classList.add('hidden'));
                libraryModalClose.addEventListener('click', closeLibraryPlayer);
                libraryModalDownload.addEventListener('click', () => downloadVideo(libraryModalBlob));

                setupVideoPlayer(videoContainer, recordedVideo, previewBigPlayButton, previewPlayPauseBtn, previewPlayPauseIcon, previewProgressBarContainer, previewProgressBar, previewMuteBtn, previewMuteIcon);
                setupVideoPlayer(libraryPlayerContainer, libraryVideoPlayer, libraryBigPlayButton, libraryPlayPauseBtn, libraryPlayPauseIcon, libraryProgressBarContainer, libraryProgressBar, libraryMuteBtn, libraryMuteIcon);
            }
            
            // --- Permissions ---
			async function checkPermissionsAndStart() {
				if (navigator.permissions) {
					try {
						const cameraStatus = await navigator.permissions.query({ name: 'camera' });
						const micStatus = await navigator.permissions.query({ name: 'microphone' });

						if (cameraStatus.state === 'granted' && micStatus.state === 'granted') {
							await startCamera();
						} else {
							showView('permissions');
						}
                    } catch (error) {
                        console.error("Permissions API not supported or error:", error);
                        showView('permissions');
                    }
                } else {
                    showView('permissions');
                }
            }
            
            async function requestCameraAndStart() {
                try {
                    await startCamera();
                } catch (err) {
                    console.error('Error getting media:', err);
                    if (err.name === 'NotAllowedError') {
                        showToast('Camera and Mic access was denied.');
                    } else if (err.name === 'NotFoundError' || err.name === 'OverconstrainedError') {
                        // Refined error
                        showToast('Could not find a suitable camera or mic.');
                    } else {
                        showToast('Error starting camera. Please refresh.');
                    }
                    showView('permissions');
                }
            }

            // --- View Management ---
            function showView(viewId) {
                if (currentView === 'preview') recordedVideo.pause();
                if (currentView === 'library') closeLibraryPlayer();
                
                Object.values(views).forEach(view => view.classList.add('hidden'));
                
                if (views[viewId]) {
                    views[viewId].classList.remove('hidden');
                    views[viewId].classList.add('flex');
                    currentView = viewId;
                    
                    if (viewId === 'library') {
                        loadLibrary();
                    }
                    if (viewId === 'preview') {
                        recordedVideo.play().catch(e => console.error("Autoplay failed:", e));
                    }
                }
            }
            
            // --- Toast Notifications ---
            function showToast(message, duration = 3000) {
                toastMessage.textContent = message;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), duration);
            }

            // --- Theme Toggling ---
            function toggleTheme() {
                document.documentElement.classList.toggle('dark');
                localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
                updateThemeIcon();
            }

            function updateThemeIcon() {
                themeIcon.classList.toggle('fa-certificate', !document.documentElement.classList.contains('dark'));
                themeIcon.classList.toggle('fa-moon', document.documentElement.classList.contains('dark'));
            }

            // --- Core Functionality ---
            function stopCurrentStream() {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
            }

            async function startCamera(preserveProgress = false) {
                stopCurrentStream();
                
                const constraints = {
                    audio: true,
                    video: { aspectRatio: 1, facingMode: facingMode }
                };

                // We 'await' here, so if it throws, the caller's catch block will get it.
                try {
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    previewVideo.srcObject = stream;
                    previewVideo.style.transform = (facingMode === 'user') ? 'scaleX(-1)' : 'scaleX(1)';

                    if (!preserveProgress) {
                        resetRecordingProgress();
                    }
                    initializeMediaRecorder();
                    showView('recording');
                } catch (err) {
                     console.error("Error in startCamera:", err.name, err.message);
                     // Re-throw the error so the caller (flipCamera or requestCameraAndStart) 
                     // can handle it and show a specific toast.
                     throw err;
                }
            }
            
			async function flipCamera() {
                // Pause recording if it's active
				if (mediaRecorder && mediaRecorder.state === 'recording') {
                    if (currentRecordMode === 'hold') {
                        // If holding, just pause.
                        handleHoldPointerUp(); // This will call pauseRecording() and update UI
                    } else {
                        // If locked, simulate a click to pause.
                        handleLockClick(); // This will call pauseRecording() and update UI
                    }
				}

                // Detach the onstop event handler from the *old*
                // mediaRecorder instance *before* we stop its stream.
                if (mediaRecorder) {
                    mediaRecorder.onstop = null;
                }

				facingMode = (facingMode === 'user') ? 'environment' : 'user';
				try {
                    // Disable controls while camera is switching
                    flipCameraButton.disabled = true;
                    recordButtonHold.disabled = true;
                    recordButtonLock.disabled = true;

					await startCamera(true); // 'true' preserves recording progress
				} catch (err) {
                    // NEW: Improved error handling
                    console.error('Failed to flip camera:', err);
                    if (err.name === 'NotFoundError' || err.name === 'OverconstrainedError') {
                        showToast("Could not switch. The other camera may not be available.");
                    } else {
                        showToast("Could not switch cameras.");
                    }
                    
                    // Restore facing mode if it failed
					facingMode = (facingMode === 'user') ? 'environment' : 'user';
				} finally {
                    // Re-enable controls
                    flipCameraButton.disabled = false;
                    recordButtonHold.disabled = false;
                    recordButtonLock.disabled = false;
                }
			}

            function resetRecordingProgress() {
                recordedChunks = [];
                totalRecordedTime = 0;
                
                updateProgressUI();
                nextButton.disabled = true;
                
                clearInterval(recordingInterval);
                
                // NEW: Reset both buttons and set mode to 'hold'
                setRecordMode('hold'); // Resets text, shows correct button
                resetButtonAppearance(); // Resets icons and animations

                console.log("Recording progress has been reset.");
            }
            
            // NEW: Resets icons and animations for BOTH buttons
            function resetButtonAppearance() {
                 // Reset Hold Button
                recordButtonHoldIcon.classList.add('fa-video');
                recordButtonHoldIcon.classList.remove('fa-stop'); // Not really used, but good to have
                recordButtonHold.classList.remove('is-recording-hold', 'is-paused');
                
                // Reset Lock Button
                recordButtonLockIcon.classList.add('fa-lock');
                recordButtonLockIcon.classList.remove('fa-stop');
                recordButtonLock.classList.remove('is-recording-lock', 'is-paused');
            }

            function initializeMediaRecorder() {
                const options = [
                    'video/mp4; codecs=avc1,mp4a.40.2',
                    'video/webm; codecs=vp9,opus',
                    'video/webm; codecs=vp8,opus',
                    'video/webm'
                ].find(type => MediaRecorder.isTypeSupported(type));

                try {
                    mediaRecorder = new MediaRecorder(stream, { mimeType: options });
                
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) recordedChunks.push(event.data);
                    };
                    
                    mediaRecorder.onstop = () => {
                        if (recordedChunks.length === 0) {
                            console.log("MediaRecorder stopped with no data.");
                            return;
                        }

                        const mimeType = recordedChunks[0].type || mediaRecorder.mimeType || 'video/mp4';
                        recordedBlob = new Blob(recordedChunks, { type: mimeType });
                        const videoURL = URL.createObjectURL(recordedBlob);
                        
                        recordedVideo.src = videoURL;
                        recordedVideo.muted = false;
                        showView('preview');
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        showToast('An error occurred during recording.');
                    };

                } catch (err) {
                    console.error('Failed to create MediaRecorder:', err);
                    showToast('This device may not be supported for recording.');
                    mediaRecorder = null;
                    showView('permissions');
                }
            }

            // --- NEW: Swipe-to-change-mode logic ---

            function handleSwipeStart(e) {
                // Don't track swipes if we are in the middle of recording
                if (mediaRecorder && mediaRecorder.state === 'recording') return;
                // Don't track if it's not the primary pointer (e.g., pinch zoom)
                if (!e.isPrimary) return;

                swipeStartX = e.clientX;
                swipeStartY = e.clientY;
            }

            function handleSwipeEnd(e) {
                // Don't track swipes if we are in the middle of recording
                if (mediaRecorder && mediaRecorder.state === 'recording') return;
                if (!e.isPrimary || swipeStartX === 0) return;

                const swipeEndX = e.clientX;
                const swipeEndY = e.clientY;
                const deltaX = swipeEndX - swipeStartX;
                const deltaY = swipeEndY - swipeStartY;

                // Reset start coordinates
                swipeStartX = 0;
                swipeStartY = 0;
                
                // Check if it's a clear horizontal swipe (more horizontal than vertical)
                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > SWIPE_THRESHOLD) {
                    if (deltaX > 0) {
                        // Swipe Right -> Show 'Hold' Mode
                        setRecordMode('hold');
                    } else {
                        // Swipe Left -> Show 'Lock' Mode
                        setRecordMode('lock');
                    }
                }
            }

            function setRecordMode(mode) {
                // Don't do anything if we're already in this mode
                if (mode === currentRecordMode) return;

                if (mode === 'lock') {
                    currentRecordMode = 'lock';
                    recordButtonHold.classList.add('hidden');
                    recordButtonLock.classList.remove('hidden');
                    recordInstructions.textContent = 'Tap to record (locked)';
                } else { // 'hold'
                    currentRecordMode = 'hold';
                    recordButtonLock.classList.add('hidden');
                    recordButtonHold.classList.remove('hidden');
                    recordInstructions.textContent = 'Hold to record, or swipe for Lock Mode';
                }
                // Reset button appearance when switching modes (in case one was paused)
                resetButtonAppearance();
            }

            // --- NEW: Event Handlers for Recording ---

            // Hold Button
            function handleHoldPointerDown(e) {
                // Prevent this from triggering swipe detection on the video
                e.stopPropagation(); 
                if (totalRecordedTime >= MAX_DURATION || !mediaRecorder) return;
                
                startRecording();
                recordButtonHold.classList.remove('is-paused');
                recordButtonHold.classList.add('is-recording-hold');
                recordInstructions.textContent = 'Release to pause';
                
                // Add listener to window to catch "drag off"
                window.addEventListener('pointerup', handleHoldPointerUp, { once: true });
            }
            
            function handleHoldPointerUp() {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    pauseRecording();
                    recordButtonHold.classList.remove('is-recording-hold');
                    if (totalRecordedTime > 0) {
                        recordButtonHold.classList.add('is-paused');
                    }
                }
                // Only reset text if we are still in hold mode
                if (currentRecordMode === 'hold') {
                     recordInstructions.textContent = 'Hold to record, or swipe for Lock Mode';
                }
            }

            // Lock Button
            function handleLockClick() {
                if (!mediaRecorder || totalRecordedTime >= MAX_DURATION) return;
                
                if (mediaRecorder.state === 'recording') {
                    // Is recording, so pause it
                    pauseRecording();
                    recordButtonLockIcon.classList.add('fa-lock');
                    recordButtonLockIcon.classList.remove('fa-stop');
                    recordButtonLock.classList.remove('is-recording-lock');
                    if (totalRecordedTime > 0) {
                        recordButtonLock.classList.add('is-paused');
                    }
                    recordInstructions.textContent = 'Tap to resume, or swipe for Hold Mode';
                } else {
                    // Is paused or inactive, so start it
                    startRecording();
                    recordButtonLockIcon.classList.add('fa-stop');
                    recordButtonLockIcon.classList.remove('fa-lock');
                    recordButtonLock.classList.remove('is-paused');
                    recordButtonLock.classList.add('is-recording-lock');
                    recordInstructions.textContent = 'Recording (Locked)...';
                }
            }
            
            // --- Original recording functions (now with UI logic removed) ---
            function startRecording() {
                if (!mediaRecorder || totalRecordedTime >= MAX_DURATION) return;
                
                if (mediaRecorder.state === 'inactive') mediaRecorder.start(100);
                else if (mediaRecorder.state === 'paused') mediaRecorder.resume();
                
                // UI logic is now in the handlers
                nextButton.disabled = true;
                chunkStartTime = Date.now();
                
                clearInterval(recordingInterval);
                recordingInterval = setInterval(updateProgress, 50);
            }

            function pauseRecording() {
                if (!mediaRecorder || mediaRecorder.state !== 'recording') return;
                
                mediaRecorder.pause();
                totalRecordedTime += Date.now() - chunkStartTime;
                clearInterval(recordingInterval);
                updateProgressUI();
                
                if (totalRecordedTime > 0) {
                    nextButton.disabled = false;
                    // UI logic is now in the handlers
                }
            }

            function updateProgress() {
                const currentTimeInChunk = Date.now() - chunkStartTime;
                const currentTotalTime = totalRecordedTime + currentTimeInChunk;
                
                if (currentTotalTime >= MAX_DURATION) {
                    // Stop based on mode
                    if (currentRecordMode === 'hold') {
                        handleHoldPointerUp();
                    } else { // 'lock'
                        handleLockClick();
                    }
                    finishRecording();
                } else {
                    updateProgressUI(currentTotalTime);
                }
            }

            function updateProgressUI(time) {
                const timeToDisplay = time !== undefined ? time : totalRecordedTime;
                const seconds = (timeToDisplay / 1000).toFixed(1);
                const progress = Math.min(timeToDisplay / MAX_DURATION, 1);
                
                timerText.textContent = `${seconds}s`;
                progressCircle.style.strokeDashoffset = circumference - (progress * circumference);
            }

            function finishRecording() {
                clearInterval(recordingInterval);

                resetButtonAppearance();
                nextButton.disabled = true;
                recordInstructions.textContent = 'Hold to record, or swipe for Lock Mode';
                
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                } else if (recordedChunks.length === 0) {
                    showToast("Hold or tap the record button to capture video first!");
                }
                stopCurrentStream();
            }
            
            // --- Video Player Logic ---
            function setupVideoPlayer(container, video, bigPlayBtn, playPauseBtn, playPauseIcon, progressContainer, progressBar, muteBtn, muteIcon) {
                const togglePlay = () => video.paused ? video.play() : video.pause();
                const toggleMute = () => video.muted = !video.muted;
                
                video.addEventListener('play', () => {
                    playPauseIcon.classList.replace('fa-play', 'fa-pause');
                    container.classList.remove('paused');
                });
                
                video.addEventListener('pause', () => {
                    playPauseIcon.classList.replace('fa-pause', 'fa-play');
                    container.classList.add('paused');
                });
                
                video.addEventListener('volumechange', () => {
                    muteIcon.classList.toggle('fa-volume-high', !video.muted);
                    muteIcon.classList.toggle('fa-volume-xmark', video.muted);
                });
                
                video.addEventListener('timeupdate', () => {
                    if (video.duration) {
                        progressBar.style.width = `${(video.currentTime / video.duration) * 100}%`;
                    }
                });
                
                progressContainer.addEventListener('click', (e) => {
                    if (video.duration) {
                        const rect = progressContainer.getBoundingClientRect();
                        video.currentTime = ((e.clientX - rect.left) / rect.width) * video.duration;
                    }
                });
                
                playPauseBtn.addEventListener('click', togglePlay);
                bigPlayBtn.addEventListener('click', togglePlay);
                muteBtn.addEventListener('click', toggleMute);
                video.addEventListener('click', (e) => {
                    // Only toggle play if the click is on the video,
                    // not part of a swipe gesture
                    if (swipeStartX === 0) {
                        togglePlay();
                    }
                });
            }
            
            // --- Library (IndexedDB) Functions ---
            function initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onupgradeneeded = e => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        }
                    };
                    request.onsuccess = e => { db = e.target.result; resolve(); };
                    request.onerror = e => reject(e.target.error);
                });
            }
            
            function generateThumbnail(blob) {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    const videoUrl = URL.createObjectURL(blob);
                    video.src = videoUrl;
                    video.muted = true;
                    video.onloadeddata = () => video.currentTime = 0.1;
                    video.onseeked = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                        URL.revokeObjectURL(videoUrl);
                        resolve(canvas.toDataURL('image/jpeg', 0.8));
                    };
                    video.onerror = (err) => {
                         URL.revokeObjectURL(videoUrl);
                         reject('Error generating thumbnail');
                    }
                });
            }
            
            async function saveVideoToLibrary(blob) {
                if (!db) return showToast("Library is not available.");
                try {
                    const thumbnail = await generateThumbnail(blob);
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    transaction.objectStore(STORE_NAME).add({
                        blob: blob,
                        date: new Date().toISOString(),
                        thumbnail: thumbnail
                    }).onsuccess = () => {
                        if (currentView === 'library') loadLibrary();
                    };
                } catch (error) {
                    showToast('Could not create video thumbnail.');
                }
            }
            
            function loadLibrary() {
                if (!db) return showToast("Library is not available.");
                const request = db.transaction([STORE_NAME], 'readonly').objectStore(STORE_NAME).getAll();
                request.onsuccess = e => {
                    const videos = e.target.result.reverse();
                    libraryGrid.innerHTML = '';
                    const isEmpty = videos.length === 0;
                    libraryEmptyState.classList.toggle('hidden', !isEmpty);
                    libraryGrid.classList.toggle('hidden', isEmpty);
                    if (!isEmpty) {
                        videos.forEach(video => libraryGrid.appendChild(createLibraryItem(video)));
                    }
                };
            }
            
            function createLibraryItem(videoRecord) {
                const item = document.createElement('div');
                item.className = 'library-item';
                const dateString = new Date(videoRecord.date).toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });

                item.innerHTML = `
                    <img src="${videoRecord.thumbnail}" class="library-item-thumbnail" alt="Video thumbnail">
                    <span class="library-item-date">${dateString}</span>
                    <button class="library-item-delete" data-id="${videoRecord.id}"><i class="fas fa-times"></i></button>
                `;
                
                item.addEventListener('click', e => {
                    if (!e.target.closest('.library-item-delete')) openLibraryPlayer(videoRecord.blob);
                });
                item.querySelector('.library-item-delete').addEventListener('click', () => deleteVideoFromLibrary(videoRecord.id));
                return item;
            }

            function deleteVideoFromLibrary(id) {
                if (!db) return showToast("Library is not available.");
                const request = db.transaction([STORE_NAME], 'readwrite').objectStore(STORE_NAME).delete(id);
                request.onsuccess = () => {
                    showToast('Video deleted.');
                    loadLibrary();
                };
                request.onerror = () => showToast('Could not delete video.');
            }
            
            function openLibraryPlayer(blob) {
                libraryModalBlob = blob;
                libraryVideoPlayer.src = URL.createObjectURL(blob);
                libraryVideoPlayer.muted = false;
                libraryModal.classList.remove('hidden');
                libraryVideoPlayer.play().catch(e => console.error("Autoplay failed:", e));
            }
            
            function closeLibraryPlayer() {
                libraryVideoPlayer.pause();
                if (libraryVideoPlayer.src) URL.revokeObjectURL(libraryVideoPlayer.src);
                libraryVideoPlayer.src = '';
                libraryModal.classList.add('hidden');
                libraryModalBlob = null;
            }

            // --- Download & Share Flow ---
            function downloadAndSaveToLibrary() {
                if (!recordedBlob) return showToast("No video to download.");
                downloadVideo(recordedBlob);
                saveVideoToLibrary(recordedBlob);
                downloadModal.classList.remove('hidden');
            }
            
            function downloadVideo(blob) {
                if (!blob) return;
                const filename = generateFilename(blob.type);
                const videoURL = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = videoURL;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(videoURL);
                }, 100);
            }

            function generateFilename(mimeType) {
                const timestamp = new Date().toISOString().replace('T', '_').replace(/:/g, '-').split('.')[0];
                const extension = mimeType.includes('mp4') ? '.mp4' : '.webm';
                return `Shortie_${timestamp}${extension}`;
            }
            
            // --- Start the app ---
            init();
        });
    </script>

</body>
</html>
